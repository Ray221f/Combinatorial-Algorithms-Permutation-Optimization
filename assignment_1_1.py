'''
Members of the group: Hao Guo, Zirui Fang
assignment_Ex1.py: The code checks if a given undirected graph contains any induced paw,
                   a paw is a 4 vertices graph that consists of a triangle and a vertex which
                   is adjacent to just one of the vertices of that triangle. The code reads
                   the graph, generates all possible 4-node combinations, and verifies if they
                   form a paw structure by counting edges and checking triangle connections.
                   If no paws are found, it outputs "It found no paws in the graph.", otherwise
                   printing out the lists of vertices in lexicographic order.        
'''

# We cite function ''are_neighbors_l'' code from Graph Algorithms, which is provided by professor Pablo Ezequiel TERLISKY on Moodle
# The function to check whether two vertices are neighbors
def are_neighbors_l(v:int, w:int)->bool:
    return (w in G_l[v])

# The function to count the total number of edges between all the vertices in nodes
def count_edges(nodes:list) -> int:
    count = 0
    for i in range(4):
        for j in range(i + 1,4):
            if are_neighbors_l(nodes[i],nodes[j]):
                count = count + 1
    return count

# The function to check if nodes are form of paw
def is_paw(nodes:list) -> bool:
    #Find all the combination of triangle
    for i in range(4):
        tri = [nodes[j] for j in range(4) if j != i]
        a_vertex = nodes[i]
        # Checks if tri is triangle
        if are_neighbors_l(tri[0],tri[1]) and are_neighbors_l(tri[0],tri[2]) and are_neighbors_l(tri[1],tri[2]):
            # Checks if a_vertex connects only one vertex of triangle
            count = 0
            for elem in tri:
                if are_neighbors_l(elem,a_vertex):
                    count = count + 1
            if count == 1:
                return True
    return False                        
                    


# Ask the user that they want to see the test cases or they want to test their own graphs
print("Enter True, if you want to see the examples from assignment and ours.")
print("Enter False, if you want to test your own graph.")
RUN_TEST = input() # input True -> "True"

# If RUN_TEST = True, then run the code of testing cases
if RUN_TEST == "True":
    # test_case_1 is the first example provided in the Exercise1
    test_case_1 = [7,10,(1,2),(1,3),(2,3),(3,4),(2,4),(0,1),(0,4),(6,4),(5,3),(2,6)]
    
    # test_case_2 is the second example provided in the Exercise1
    test_case_2 = [6,12,(0,1),(0,3),(1,3),(2,1),(2,4),(4,1),(5,3),(5,4),(3,4),(0,2),(0,5), (2,5)]
    
    # test_case_3 is an example of graph with 10 vertices that has at least 4 paws
    test_case_3 = [10,11,(1,0),(1,2),(1,3),(2,3),(3,4),(4,5),(5,6),(5,7),(5,8),(5,9),(8,9)]
    
    # test_case_4 is an example of graph with 10 vertices that is connected and has no paws
    test_case_4 = [10,9,(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)]
    
    # Prints out all the results of these 4 cases
    for case in [test_case_1, test_case_2, test_case_3, test_case_4]:
            n, m = case[0], case[1]
            # We cite adjacency list representation code from graphs-algorithms.py, which is provided by professor Pablo Ezequiel TERLISKY on Moodle
            # Adjacency List Representation
            # Initialization
            G_l = []
            for i in range(n):
                G_l.append([])
            # Adding all the edges
            for (v,w) in case[2:]:
                G_l[v].append(w)
                G_l[w].append(v)
            # Generating all possible cases of nodes which are paw
            # The order of nodes of paws generated by this for loop structure forms lexicographical order
            paws = []
            for a in range(n):
                for b in range(a+1, n):
                    for c in range(b+1, n):
                        for d in range(c+1, n):
                            nodes = [a, b, c, d]
                            if count_edges(nodes) == 4 and is_paw(nodes):
                                paws.append(nodes)    
            print(f"\nThe number of vertices: {n}, The number of edges: {m}")
            print("The existence of edges are:",[(v,w) for (v,w) in case[2:]])
            print(f"Found {len(paws)} paws:")
            # Printing out the result
            if len(paws) == 0:
                print("It found no paws in the graph.")
            else:
                for p in paws:
                    print(p) 
       
# If RUN_TEST = False, then run the code of manual input
else:
    print("\nEnter gragh data:")
    line = input()            # input 7 10 -> "7 10"           
    parts = line.split()      # "7 10".split() -> ["7", "10"] 
    n = int(parts[0])         # n = int("7") = 7
    m = int(parts[1])         # m = int("10") = 10

    # We cite adjacency list representation code from graphs-algorithms.py, which is provided by professor Pablo Ezequiel TERLISKY on Moodle
    # Adjacency List Representation
    # Initialization
    G_l = []
    for i in range(n):
        G_l.append([])
    
    # Adding all the edges
    for i in range(m):
        edge_line = input()            # input 1 2 -> "1 2"
        edge_parts = edge_line.split() # "1 2".split() -> ["1", "2"]
        v = int(edge_parts[0])         # v = int("1") = 1
        w = int(edge_parts[1])         # w = int("2") = 2
        G_l[v].append(w)
        G_l[w].append(v)

    # Generating all possible cases of nodes which are paw
    # The order of nodes of paws generated by this for loop structure forms lexicographical order
    paws = []
    for a in range(n):
        for b in range(a + 1, n):
            for c in range(b + 1, n):
                for d in range(c + 1, n):
                    nodes = [a, b, c, d]    # The vertex of nodes are in ascending order
                    if count_edges(nodes) == 4:
                        if is_paw(nodes):
                            paws.append(nodes)

    # Printing out the result
    if len(paws) == 0:
        print("It found no paws in the graph.")
    else:
        for p in paws:
            print(p)
